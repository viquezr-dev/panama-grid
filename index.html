<!DOCTYPE html>
<html>
<head>
    <title>SISTEMA POSTAL DE PANAM√Å</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body, html, #mapid { width: 100%; height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; }
        .map-title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 4000; text-align: center; pointer-events: none; width: 90%; }
        .map-title h1 { margin: 0; font-size: 18px; color: #2c3e50; text-shadow: 0 0 5px white; font-weight: bold; }
        .search-container { position: absolute; top: 15px; right: 10px; z-index: 5000; display: flex; background: white; padding: 5px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); width: 250px; }
        input#search-input { flex: 1; border: none; padding: 8px; outline: none; }
        button#search-btn { background: #2c3e50; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; }
        .leaflet-top.leaflet-right { top: 80px !important; }
        .toggle-watermark { position: absolute; bottom: 30px; left: 10px; z-index: 5000; background: white; padding: 10px; border-radius: 5px; cursor: pointer; font-size: 11px; border: 1px solid #1a73e8; font-weight: bold; }
        .watermark-label-fixed { background: none!important; border:none!important; color: #1a73e8!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; }
        .micro-label-fixed { background: none!important; border:none!important; color: #3498db!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 9px; }
        .nano-label-fixed { background: none!important; border:none!important; color: #2980b9!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 8px; }
        .nano-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .micro-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .btn-nav, .btn-ws { display: inline-block; padding: 8px 12px; color: white!important; text-decoration: none!important; border-radius: 5px; font-weight: bold; font-size: 11px; margin: 2px; border:none; cursor: pointer; }
        .btn-nav { background-color: #3498db; }
        .btn-ws { background-color: #25D366; }
        .locate-button { width: 30px; height: 30px; line-height: 30px; text-align: center; display: block; text-decoration: none; color: black; background: white; font-size: 18px; cursor: pointer; }
        .user-location-icon { text-align: center; font-size: 20px; }
        .highlighted-polygon { animation: pulse 2s infinite; }
        @keyframes pulse {
            0% { fill-opacity: 0.3; }
            50% { fill-opacity: 0.7; }
            100% { fill-opacity: 0.3; }
        }
        .warning-popup .leaflet-popup-content-wrapper {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
        }
        .warning-popup .leaflet-popup-tip {
            background: #ffc107;
        }
        .estafeta-popup .leaflet-popup-content-wrapper {
            background: #d4edda;
            border: 2px solid #28a745;
            border-radius: 8px;
        }
        .estafeta-popup .leaflet-popup-tip {
            background: #28a745;
        }
        .ruta-popup .leaflet-popup-content-wrapper {
            background: #f8d7da;
            border: 2px solid #dc3545;
            border-radius: 8px;
        }
        .ruta-popup .leaflet-popup-tip {
            background: #dc3545;
        }
        .zona-popup .leaflet-popup-content-wrapper {
            background: #e9ecef;
            border: 2px solid #6c757d;
            border-radius: 8px;
        }
        .zona-popup .leaflet-popup-tip {
            background: #6c757d;
        }
        .grid-macro { stroke-dasharray: none; }
        .grid-micro { stroke-dasharray: 5, 5; }
        .grid-nano { stroke-dasharray: 2, 3; }
        .nano-popup .leaflet-popup-content-wrapper {
            background: #e3f2fd;
            border: 2px solid #1976d2;
            border-radius: 8px;
            max-width: 350px;
        }
        .nano-popup .leaflet-popup-tip {
            background: #1976d2;
        }
        .codigo-final {
            background: #1976d2;
            color: white;
            padding: 12px 15px;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            margin: 10px 0;
            text-align: center;
            letter-spacing: 1px;
        }
        .codigo-completo {
            background: #f8f9fa;
            color: #495057;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            margin: 8px 0;
            text-align: center;
            border: 1px solid #dee2e6;
        }
        .leaflet-tooltip {
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid #1a73e8;
        border-radius: 3px;
        padding: 3px 6px;
        font-size: 11px;
        font-weight: bold;
        color: #1a73e8;
        }
    </style>
</head>
<body>

<div class="map-title"><h1>SISTEMA POSTAL DE PANAM√Å</h1></div>
<div class="search-container">
    <input type="text" id="search-input" placeholder="Ej: A0001 o A0001-GT674-A5C">
    <button id="search-btn">IR</button>
</div>
<div id="toggle-wm" class="toggle-watermark">TEXTO: ON</div>
<div id="mapid"></div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/@mapbox/leaflet-pip@latest/leaflet-pip.js"></script>

<script>
const mymap = L.map('mapid').setView([8.50, -80.0], 8);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mymap);

// Capas
const zonasGeoLayer = L.layerGroup().addTo(mymap);
const cuadriculaFisicaLayer = L.layerGroup().addTo(mymap);
const gridLayer = L.layerGroup().addTo(mymap);
const labelLayer = L.layerGroup().addTo(mymap);
const selectionLayer = L.layerGroup().addTo(mymap);
const rutasLayer = L.layerGroup().addTo(mymap);
const estafetasPointsLayer = L.layerGroup().addTo(mymap);
const userLocationLayer = L.layerGroup().addTo(mymap);

let rawCuadricula = null, rawZonas = null;
let rutasData = null, estafetasData = null;
let labelsEnabled = true;
const ALFABETO = "ABCDEFGHJKLMNPQRSTUVWXYZ";
const NANO_RES = 25; 
const NUMEROS = "0123456789";

// CACHE para watermarks micro y nano
const microWatermarkCache = new Map();
const nanoWatermarkCache = new Map();

// Variable para almacenar labels temporales que se deben restaurar
let hiddenLabels = [];

// Funci√≥n para generar el c√≥digo macro usando el campo codigo_macro del archivo cuadricula.geojson
function generarCodigoMacro(feature) {
    // Usar directamente el campo codigo_macro del archivo cuadricula.geojson
    if (feature.properties && feature.properties.codigo_macro) {
        const codigo = feature.properties.codigo_macro;
        console.log(`DEBUG: Obteniendo codigo_macro para feature ${feature.properties.fid}: "${codigo}"`);
        return codigo;
    }
    // Fallback por si alg√∫n cuadro no tiene el campo
    console.warn(`DEBUG: Feature ${feature.properties.fid} no tiene codigo_macro, usando SINCOD`);
    return "SINCOD";
}

// Funci√≥n hash mejorada para generar c√≥digos desordenados
function hashPosition(ix, iy, salt = 0) {
    let hash = (ix * 15485863) ^ (iy * 2860486313) ^ (salt * 5915587277);
    hash = (hash * 2654435761) >>> 0;
    return Math.abs(hash % 1000000);
}

// Funci√≥n para generar c√≥digo nano LNN desordenado pero determinista
function generateNanoCode(nix, niy, microIx, microIy) {
    const salt = microIx * 24 + microIy;
    const hash = hashPosition(nix, niy, salt);
    
    const letterIndex = (hash % 24);
    const num1 = Math.floor((hash / 24) % 10);
    const num2 = Math.floor((hash / 240) % 10);
    
    return `${ALFABETO[letterIndex]}${num1}${num2}`;
}

function getPointInGrid(coords, col, row, totalCols, totalRows) {
    const p0 = coords[0], p1 = coords[1], p2 = coords[2], p3 = coords[3];
    const tX = col / totalCols, tY = row / totalRows;
    const lat = (1-tY)*((1-tX)*p0[1] + tX*p1[1]) + tY*((1-tX)*p3[1] + tX*p2[1]);
    const lng = (1-tY)*((1-tX)*p0[0] + tX*p1[0]) + tY*((1-tX)*p3[0] + tX*p2[0]);
    return [lat, lng];
}

// Funci√≥n para obtener c√≥digo micro LNLN DETERMINISTA (sin n√∫meros aleatorios)
function getMicroCodeFromIndices(ix, iy) {
    // Funci√≥n determinista basada en √≠ndices
    const hash = (ix * 37) ^ (iy * 17);
    const letterIndex1 = Math.abs((hash * 11) % 24);
    const number1 = Math.abs((hash * 7) % 10);
    const letterIndex2 = Math.abs((hash * 13) % 24);
    const number2 = Math.abs((hash * 19) % 10);
    
    return `${ALFABETO[letterIndex1]}${number1}${ALFABETO[letterIndex2]}${number2}`;
}

function getCacheKey(featureId, level, i, j, ni = null, nj = null) {
    if (ni !== null && nj !== null) {
        return `f${featureId}-${level}-${i}-${j}-${ni}-${nj}`;
    }
    return `f${featureId}-${level}-${i}-${j}`;
}

// Funci√≥n para encontrar watermark m√°s cercano
function findClosestWatermark(clickLatLng, watermarkCache, maxDistance = 0.001) {
    let closestWatermark = null;
    let minDistance = Infinity;
    let closestKey = null;
    
    watermarkCache.forEach((watermark, key) => {
        const dx = clickLatLng.lng - watermark.center[1];
        const dy = clickLatLng.lat - watermark.center[0];
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        if (distance < minDistance && distance < maxDistance) {
            minDistance = distance;
            closestWatermark = watermark;
            closestKey = key;
        }
    });
    
    if (closestWatermark) {
        console.log(`Watermark encontrado: ${closestKey}, distancia: ${minDistance.toFixed(6)}`);
    }
    
    return closestWatermark;
}

// Funci√≥n para calcular en qu√© celda nano est√° un punto dado
function calculateNanoIndicesFromPoint(lat, lng, feature, microWatermark) {
    const b = L.geoJSON(feature).getBounds();
    const coords = feature.geometry.coordinates[0];
    
    const relX = (lng - b.getWest()) / (b.getEast() - b.getWest());
    const relY = (lat - b.getSouth()) / (b.getNorth() - b.getSouth());
    
    const safeRelX = Math.min(0.9999999, Math.max(0.0000001, relX));
    const safeRelY = Math.min(0.9999999, Math.max(0.0000001, relY));
    
    const microIx = Math.floor(safeRelX * 24);
    const microIy = Math.floor(safeRelY * 24);
    
    const cellRelX = (safeRelX * 24) - microIx;
    const cellRelY = (safeRelY * 24) - microIy;
    
    const nix = Math.floor(cellRelX * NANO_RES);
    const niy = Math.floor(cellRelY * NANO_RES);
    
    return {
        microIx: Math.min(23, Math.max(0, microIx)),
        microIy: Math.min(23, Math.max(0, microIy)),
        nix: Math.min(NANO_RES-1, Math.max(0, nix)),
        niy: Math.min(NANO_RES-1, Math.max(0, niy))
    };
}

// Funci√≥n para obtener VM_LEVEL desde el pol√≠gono estafetas.geojson
function obtenerVMLEVEL(latlng) {
    if (!rawZonas) return null;
    
    const punto = [latlng.lng, latlng.lat];
    const zonasEnPunto = leafletPip.pointInLayer(punto, L.geoJSON(rawZonas));
    
    if (zonasEnPunto.length > 0) {
        const vmLevel = zonasEnPunto[0].feature.properties.VM_LEVEL;
        console.log("VM_LEVEL encontrado:", vmLevel);
        return vmLevel;
    }
    
    console.log("No se encontr√≥ VM_LEVEL para esta ubicaci√≥n");
    return null;
}

// Funci√≥n para obtener los √∫ltimos 6 d√≠gitos del c√≥digo postal
function obtenerUltimos6Digitos(codigoCompleto) {
    // Remover guiones y tomar √∫ltimos 6 caracteres
    const codigoSinGuiones = codigoCompleto.replace(/-/g, '');
    return codigoSinGuiones.slice(-6);
}

function updateGridAndLabels() {
     gridLayer.clearLayers();
    labelLayer.clearLayers();
    microWatermarkCache.clear();
    nanoWatermarkCache.clear();
    hiddenLabels = []; // Limpiar labels ocultos
    
    if (!rawCuadricula) return;
    const z = mymap.getZoom();
    const bounds = mymap.getBounds();

    rawCuadricula.features.forEach((f, featureIndex) => {
        const fBounds = L.geoJSON(f).getBounds();
        if (!bounds.intersects(fBounds)) return;
        
        const coords = f.geometry.coordinates[0];
        
        // Obtener el c√≥digo macro del campo codigo_macro
        const codigoMacro = generarCodigoMacro(f);
        
        // Labels para macro (zoom 10-14) - USAR EL C√ìDIGO MACRO DEL CAMPO
        if (z >= 10 && z < 14 && labelsEnabled) {
            L.marker(fBounds.getCenter(), {
                icon: L.divIcon({ 
                    className: 'watermark-label-fixed', 
                    html: `<div title="FID: ${f.properties.fid}">${codigoMacro}</div>`, 
                    iconSize: [60, 20] 
                })
            }).addTo(labelLayer);
        }
        
        // Labels y cache para micro (zoom 14-17)
        for (let i = 0; i < 24; i++) {
            for (let j = 0; j < 24; j++) {
                const center = getPointInGrid(coords, i + 0.5, j + 0.5, 24, 24);
                const microCode = getMicroCodeFromIndices(i, j);
                
                const cacheKey = getCacheKey(featureIndex, 'micro', i, j);
                microWatermarkCache.set(cacheKey, {
                    center: center,
                    code: microCode,
                    bounds: [
                        getPointInGrid(coords, i, j, 24, 24),
                        getPointInGrid(coords, i+1, j, 24, 24),
                        getPointInGrid(coords, i+1, j+1, 24, 24),
                        getPointInGrid(coords, i, j+1, 24, 24)
                    ],
                    indices: { ix: i, iy: j },
                    codigoMacro: codigoMacro // Agregar el c√≥digo macro al cache
                });
                
                if (z >= 14 && z < 17 && labelsEnabled) {
                    L.marker(center, {
                        icon: L.divIcon({ 
                            className: 'micro-label-fixed', 
                            html: microCode, 
                            iconSize: [45, 15] 
                        })
                    }).addTo(labelLayer);
                }
            }
        }
        
        // Cache para nano (zoom >= 17)
        if (z >= 17) {
            for (let i = 0; i < 24; i++) {
                for (let j = 0; j < 24; j++) {
                    for (let ni = 0; ni < NANO_RES; ni++) {
                        for (let nj = 0; nj < NANO_RES; nj++) {
                            const nanoCenter = getPointInGrid(coords, i + (ni + 0.5)/NANO_RES, j + (nj + 0.5)/NANO_RES, 24, 24);
                            
                            if (bounds.contains(nanoCenter)) {
                                const nanoCode = generateNanoCode(ni, nj, i, j);
                                
                                const cacheKey = getCacheKey(featureIndex, 'nano', i, j, ni, nj);
                                nanoWatermarkCache.set(cacheKey, {
                                    center: nanoCenter,
                                    code: nanoCode,
                                    bounds: [
                                        getPointInGrid(coords, i + ni/NANO_RES, j + nj/NANO_RES, 24, 24),
                                        getPointInGrid(coords, i + (ni+1)/NANO_RES, j + nj/NANO_RES, 24, 24),
                                        getPointInGrid(coords, i + (ni+1)/NANO_RES, j + (nj+1)/NANO_RES, 24, 24),
                                        getPointInGrid(coords, i + ni/NANO_RES, j + (nj+1)/NANO_RES, 24, 24)
                                    ],
                                    indices: { microIx: i, microIy: j, nix: ni, niy: nj },
                                    codigoMacro: codigoMacro // Agregar el c√≥digo macro al cache
                                });
                                
                                if (labelsEnabled && ni % 5 === 0 && nj % 5 === 0) {
                                    L.marker(nanoCenter, {
                                        icon: L.divIcon({ 
                                            className: 'nano-label-fixed', 
                                            html: nanoCode, 
                                            iconSize: [35, 10] 
                                        })
                                    }).addTo(labelLayer);
                                }
                            }
                        }
                    }
                }
            }
        }

        // REJILLA DIN√ÅMICA MEJORADA
        if (z >= 10 && mymap.hasLayer(gridLayer)) {
            if (z >= 10 && z < 14) {
                // S√ìLO L√çNEAS PRINCIPALES DE MACRO
                L.polygon(coords, {
                    color: "#1a73e8",
                    weight: 2,
                    opacity: 0.6,
                    fillOpacity: 0,
                    className: 'grid-macro'
                }).addTo(gridLayer);
                
            } else if (z >= 14 && z < 17) {
                // L√çNEAS MICRO - m√°s gruesas y visibles
                for (let i = 0; i <= 24; i++) {
                    let v = [], h = [];
                    for(let j=0; j<=24; j++) {
                        v.push(getPointInGrid(coords, i, j, 24, 24));
                        h.push(getPointInGrid(coords, j, i, 24, 24));
                    }
                    
                    // L√≠neas principales cada 6 celdas (1/4 del grid)
                    if (i % 6 === 0) {
                        L.polyline(v, {
                            color: "#3498db",
                            weight: 1.5,
                            opacity: 0.7,
                            className: 'grid-micro'
                        }).addTo(gridLayer);
                        L.polyline(h, {
                            color: "#3498db",
                            weight: 1.5,
                            opacity: 0.7,
                            className: 'grid-micro'
                        }).addTo(gridLayer);
                    } else {
                        // L√≠neas secundarias
                        L.polyline(v, {
                            color: "#3498db",
                            weight: 0.8,
                            opacity: 0.4,
                            dashArray: '5, 5',
                            className: 'grid-micro'
                        }).addTo(gridLayer);
                        L.polyline(h, {
                            color: "#3498db",
                            weight: 0.8,
                            opacity: 0.4,
                            dashArray: '5, 5',
                            className: 'grid-micro'
                        }).addTo(gridLayer);
                    }
                }
                
                // Borde del macro
                L.polygon(coords, {
                    color: "#1a73e8",
                    weight: 2,
                    opacity: 0.8,
                    fillOpacity: 0,
                    className: 'grid-macro'
                }).addTo(gridLayer);
                
            } else if (z >= 17) {
                // L√çNEAS NANO - muy finas
                for (let i = 0; i < 24; i++) {
                    for (let j = 0; j < 24; j++) {
                        const topLeft = getPointInGrid(coords, i, j, 24, 24);
                        const topRight = getPointInGrid(coords, i+1, j, 24, 24);
                        const bottomRight = getPointInGrid(coords, i+1, j+1, 24, 24);
                        const bottomLeft = getPointInGrid(coords, i, j+1, 24, 24);
                        
                        // L√≠neas verticales NANO (solo cada 5 l√≠neas para no saturar)
                        for (let ni = 1; ni < NANO_RES; ni++) {
                            if (ni % 5 === 0) {
                                const t = ni / NANO_RES;
                                const p1 = [
                                    (1-t) * topLeft[0] + t * topRight[0],
                                    (1-t) * topLeft[1] + t * topRight[1]
                                ];
                                const p2 = [
                                    (1-t) * bottomLeft[0] + t * bottomRight[0],
                                    (1-t) * bottomLeft[1] + t * bottomRight[1]
                                ];
                                L.polyline([p1, p2], {
                                    color: "#2980b9",
                                    weight: 0.4,
                                    opacity: 0.3,
                                    dashArray: '2, 3',
                                    className: 'grid-nano'
                                }).addTo(gridLayer);
                            }
                        }
                        
                        // L√≠neas horizontales NANO (solo cada 5 l√≠neas)
                        for (let nj = 1; nj < NANO_RES; nj++) {
                            if (nj % 5 === 0) {
                                const t = nj / NANO_RES;
                                const p1 = [
                                    (1-t) * topLeft[0] + t * bottomLeft[0],
                                    (1-t) * topLeft[1] + t * bottomLeft[1]
                                ];
                                const p2 = [
                                    (1-t) * topRight[0] + t * bottomRight[0],
                                    (1-t) * topRight[1] + t * bottomRight[1]
                                ];
                                L.polyline([p1, p2], {
                                    color: "#2980b9",
                                    weight: 0.4,
                                    opacity: 0.3,
                                    dashArray: '2, 3',
                                    className: 'grid-nano'
                                }).addTo(gridLayer);
                            }
                        }
                    }
                }
                
                // L√≠neas MICRO visibles en nivel nano (m√°s gruesas)
                for (let i = 0; i <= 24; i++) {
                    let v = [], h = [];
                    for(let j=0; j<=24; j++) {
                        v.push(getPointInGrid(coords, i, j, 24, 24));
                        h.push(getPointInGrid(coords, j, i, 24, 24));
                    }
                    
                    L.polyline(v, {
                        color: "#3498db",
                        weight: 1.0,
                        opacity: 0.6,
                        className: 'grid-micro'
                    }).addTo(gridLayer);
                    L.polyline(h, {
                        color: "#3498db",
                        weight: 1.0,
                        opacity: 0.6,
                        className: 'grid-micro'
                    }).addTo(gridLayer);
                }
                
                // Borde del macro
                L.polygon(coords, {
                    color: "#1a73e8",
                    weight: 2,
                    opacity: 0.8,
                    fillOpacity: 0,
                    className: 'grid-macro'
                }).addTo(gridLayer);
            }
        }
    });
}

// Carga de Datos
$.getJSON("cuadricula.geojson", d => { 
    rawCuadricula = d; 
    console.log("=== CUADR√çCULA CARGADA ===");
    console.log("Total de cuadros:", d.features.length);
    console.log("Primeros 5 cuadros:");
    d.features.slice(0, 5).forEach((f, i) => {
        console.log(`  ${i+1}. FID: ${f.properties.fid}, codigo_macro: "${f.properties.codigo_macro}"`);
    });
    
    L.geoJSON(d, {
        style: {color: "#3498db", weight: 1, fillOpacity: 0.05},
        onEachFeature: function(feature, layer) {
            // Agregar tooltip para verificar el c√≥digo
            layer.bindTooltip(`Macro: ${feature.properties.codigo_macro || "N/A"}`, {
                permanent: false,
                direction: 'center'
            });
        }
    }).addTo(cuadriculaFisicaLayer);
    
    updateGridAndLabels(); 
});
$.getJSON("estafetas.geojson", d => { 
    rawZonas = d; 
    L.geoJSON(d, {
        style: {color: "#2c3e50", weight: 1.5, fillOpacity: 0.05},
        onEachFeature: function(feature, layer) {
            // Agregar evento de clic para zonas
            layer.on('click', function(e) {
                mostrarPopupZona(e.latlng, feature);
                L.DomEvent.stopPropagation(e); // Detener propagaci√≥n
            });
        }
    }).addTo(zonasGeoLayer); 
});
$.getJSON("estafetasl.geojson", d => { 
    rutasData = d;
    L.geoJSON(d, {
        style: function(feature) {
            return {
                color: "#e74c3c", 
                weight: 4,  // Aumentado para mejor detecci√≥n
                opacity: 0.8
            };
        },
        onEachFeature: function(feature, layer) {
            // Agregar evento de clic para rutas
            layer.on('click', function(e) {
                mostrarPopupRuta(e.latlng, feature);
                L.DomEvent.stopPropagation(e); // Detener propagaci√≥n
            });
        }
    }).addTo(rutasLayer);
});
$.getJSON("estafetasp.geojson", d => { 
    estafetasData = d;
    L.geoJSON(d, {
        pointToLayer: (f, ll) => L.circleMarker(ll, {
            radius: 8,  // Aumentado el radio
            color: "#27ae60", 
            fillColor: "#2ecc71", 
            fillOpacity: 0.9,
            weight: 3
        }),
        onEachFeature: function(feature, layer) {
            // Agregar evento de clic para estafetas
            layer.on('click', function(e) {
                mostrarPopupEstafeta(e.latlng, feature);
                L.DomEvent.stopPropagation(e); // Detener propagaci√≥n
            });
        }
    }).addTo(estafetasPointsLayer);
});

// Funci√≥n para restaurar labels ocultos
function restoreHiddenLabels() {
    hiddenLabels.forEach(layer => {
        if (layer && typeof layer.setOpacity === 'function') {
            layer.setOpacity(1);
        }
    });
    hiddenLabels = [];
}

// FUNCI√ìN PARA DETECTAR CLIC EN ZONAS (SOLO CUANDO LA CAPA EST√Å ACTIVA)
function verificarClicEnZonas(latlng) {
    if (!rawZonas || !mymap.hasLayer(zonasGeoLayer)) return null;
    
    const punto = [latlng.lng, latlng.lat];
    const zonasEnPunto = leafletPip.pointInLayer(punto, L.geoJSON(rawZonas));
    
    if (zonasEnPunto.length > 0) {
        console.log("Zona encontrada:", zonasEnPunto[0].feature.properties.VM_LEVEL);
        return zonasEnPunto[0].feature;
    }
    
    return null;
}

// FUNCI√ìN COMPLETAMENTE NUEVA PARA DETECTAR ESTAFETAS - POR PROXIMIDAD
function verificarClicEnEstafetas(latlng) {
    if (!estafetasData || !mymap.hasLayer(estafetasPointsLayer)) return null;
    
    console.log("Buscando estafetas cerca de:", latlng.lat.toFixed(6), latlng.lng.toFixed(6));
    
    let estafetaMasCercana = null;
    let distanciaMinima = Infinity;
    const TOLERANCIA_METROS = 15; // 15 metros de tolerancia
    
    // Convertir tolerancia de metros a grados (aproximadamente)
    const toleranceDegrees = TOLERANCIA_METROS / 111000; // 1 grado ‚âà 111km
    
    estafetasData.features.forEach(feature => {
        if (feature.geometry.type === 'Point') {
            const puntoEstafeta = {
                lat: feature.geometry.coordinates[1],
                lng: feature.geometry.coordinates[0]
            };
            
            // Calcular distancia euclidiana en grados
            const dx = latlng.lng - puntoEstafeta.lng;
            const dy = latlng.lat - puntoEstafeta.lat;
            const distancia = Math.sqrt(dx * dx + dy * dy);
            
            console.log(`  Estafeta ${feature.properties.ESTAF_NAME}: distancia=${distancia.toFixed(6)} grados`);
            
            if (distancia < distanciaMinima && distancia < toleranceDegrees) {
                distanciaMinima = distancia;
                estafetaMasCercana = feature;
            }
        }
    });
    
    if (estafetaMasCercana) {
        console.log(`Estafeta m√°s cercana: ${estafetaMasCercana.properties.ESTAF_NAME}, distancia: ${distanciaMinima.toFixed(6)} grados`);
        return estafetaMasCercana;
    }
    
    return null;
}

// FUNCI√ìN COMPLETAMENTE NUEVA PARA DETECTAR RUTAS - M√ÅS PRECISA
function verificarClicEnRutas(latlng) {
    if (!rutasData || !mymap.hasLayer(rutasLayer)) return null;
    
    console.log("Buscando rutas cerca de:", latlng.lat.toFixed(6), latlng.lng.toFixed(6));
    
    let rutaMasCercana = null;
    let distanciaMinima = Infinity;
    const TOLERANCIA_METROS = 10; // 10 metros de tolerancia
    
    // Convertir tolerancia de metros a grados (aproximadamente)
    const toleranceDegrees = TOLERANCIA_METROS / 111000; // 1 grado ‚âà 111km
    
    rutasData.features.forEach(feature => {
        if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {
            let coordinates = [];
            
            // Manejar ambos tipos de geometr√≠a
            if (feature.geometry.type === 'LineString') {
                coordinates = feature.geometry.coordinates;
            } else if (feature.geometry.type === 'MultiLineString') {
                // Para MultiLineString, aplanar todas las l√≠neas
                feature.geometry.coordinates.forEach(line => {
                    coordinates = coordinates.concat(line);
                });
            }
            
            // Para cada segmento de la l√≠nea
            for (let i = 0; i < coordinates.length - 1; i++) {
                const p1 = {
                    lng: coordinates[i][0],
                    lat: coordinates[i][1]
                };
                const p2 = {
                    lng: coordinates[i + 1][0],
                    lat: coordinates[i + 1][1]
                };
                
                // Calcular distancia del punto al segmento
                const distancia = distanciaPuntoASegmento(latlng, p1, p2);
                
                if (distancia < distanciaMinima && distancia < toleranceDegrees) {
                    distanciaMinima = distancia;
                    rutaMasCercana = feature;
                    console.log(`Ruta encontrada: ${feature.properties.RUTA}, distancia: ${distancia.toFixed(6)} grados`);
                }
            }
        }
    });
    
    if (rutaMasCercana) {
        console.log(`Ruta m√°s cercana: ${rutaMasCercana.properties.RUTA}, distancia: ${distanciaMinima.toFixed(6)} grados`);
        return rutaMasCercana;
    }
    
    return null;
}

// Funci√≥n para calcular distancia de punto a segmento (versi√≥n mejorada)
function distanciaPuntoASegmento(p, a, b) {
    // Calcular vectores
    const A = p.lng - a.lng;
    const B = p.lat - a.lat;
    const C = b.lng - a.lng;
    const D = b.lat - a.lat;
    
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    
    // Si el segmento tiene longitud cero, calcular distancia al punto a
    if (lenSq === 0) {
        const dx = p.lng - a.lng;
        const dy = p.lat - a.lat;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    let param = dot / lenSq;
    
    let xx, yy;
    
    if (param < 0) {
        xx = a.lng;
        yy = a.lat;
    } else if (param > 1) {
        xx = b.lng;
        yy = b.lat;
    } else {
        xx = a.lng + param * C;
        yy = a.lat + param * D;
    }
    
    const dx = p.lng - xx;
    const dy = p.lat - yy;
    
    return Math.sqrt(dx * dx + dy * dy);
}

// EVENTO CLIC CORREGIDO - AHORA CON ZONAS SEPARADAS
mymap.on("click", function (e) {
    console.log("=== CLIC EN MAPA (√ÅREA GENERAL) ===");
    console.log("Coordenadas:", e.latlng.lat.toFixed(6), e.latlng.lng.toFixed(6));
    
    // Limpiar selecci√≥n anterior y restaurar labels
    selectionLayer.clearLayers();
    restoreHiddenLabels();
    hiddenLabels = [];
    
    // PRIMERO: Verificar si se hizo clic en una estafeta
    const estafetaClic = verificarClicEnEstafetas(e.latlng);
    if (estafetaClic) {
        mostrarPopupEstafeta(e.latlng, estafetaClic);
        return; // Detener aqu√≠
    }
    
    // SEGUNDO: Verificar si se hizo clic en una ruta
    const rutaClic = verificarClicEnRutas(e.latlng);
    if (rutaClic) {
        mostrarPopupRuta(e.latlng, rutaClic);
        return; // Detener aqu√≠
    }
    
    // TERCERO: Verificar si se hizo clic en una zona (SOLO si la capa est√° activa)
    const zonaClic = verificarClicEnZonas(e.latlng);
    if (zonaClic) {
        mostrarPopupZona(e.latlng, zonaClic);
        return; // Detener aqu√≠ - zonas tienen su propio popup
    }
    
    // CUARTO: Si no es estafeta, ruta ni zona, procesar c√≥digo postal (SIEMPRE de la cuadr√≠cula)
    if (!rawCuadricula) return;
    
    // Buscar en la cuadr√≠cula (SOLO cuadr√≠cula, no en zonas)
    const hC = leafletPip.pointInLayer([e.latlng.lng, e.latlng.lat], L.geoJSON(rawCuadricula));

    // VERIFICAR SI EST√Å EN √ÅREA NO DEFINIDA
    if (hC.length === 0) {
        mostrarPopupAreaNoDefinida(e.latlng);
        return;
    }

    // SIEMPRE usar el c√≥digo de la cuadr√≠cula, ignorar zonas
    const macroID = generarCodigoMacro(hC[0].feature);
    console.log(`CLIC: Cuadro seleccionado - FID: ${hC[0].feature.properties.fid}, codigo_macro: "${macroID}"`);
    
    let titulo = "ZONAS POSTALES", finalCode = macroID;
    const z = mymap.getZoom();
    const featureIndex = rawCuadricula.features.findIndex(f => f === hC[0].feature);

    console.log(`Zoom: ${z}, Macro: ${macroID}, FeatureIndex: ${featureIndex}`);

    if (z < 14) {
        // Nivel macro - NO MOSTRAR POPUP, solo seleccionar
        const selectedFeature = hC[0].feature;
        L.geoJSON(selectedFeature, {
            style: {
                color: "#1a73e8", 
                weight: 4, 
                fillColor: "#1a73e8",
                fillOpacity: 0.3,
                className: 'highlighted-polygon'
            }
        }).addTo(selectionLayer);
        return; // No mostrar popup
        
    } else if (z >= 14 && z < 17) {
        // NIVEL MICRO - NO MOSTRAR POPUP, solo seleccionar
        const closestWatermark = findClosestWatermark(e.latlng, microWatermarkCache, 0.01);
        
        if (closestWatermark) {
            L.polygon(closestWatermark.bounds, {
                color: "#3498db", 
                weight: 3, 
                fillColor: "#3498db",
                fillOpacity: 0.5,
                className: 'highlighted-polygon'
            }).addTo(selectionLayer);
        }
        return; // No mostrar popup
        
    } else {
        // NIVEL NANO - AQU√ç S√ç MOSTRAR POPUP COMPLETO
        titulo = "C√ìDIGO POSTAL";
        
        // Buscar en cache nano primero
        const closestWatermark = findClosestWatermark(e.latlng, nanoWatermarkCache, 0.002);
        
        let microCode = "", nanoCode = "";
        
        if (closestWatermark) {
            // Obtener c√≥digo micro del cache
            const microKey = getCacheKey(featureIndex, 'micro', 
                closestWatermark.indices.microIx, 
                closestWatermark.indices.microIy);
            const microWatermark = microWatermarkCache.get(microKey);
            microCode = microWatermark ? microWatermark.code : getMicroCodeFromIndices(
                closestWatermark.indices.microIx, 
                closestWatermark.indices.microIy
            );
            nanoCode = closestWatermark.code;
            
            // C√≥digo completo
            finalCode = `${macroID}-${microCode}-${nanoCode}`;
            
            // MOSTRAR CUADRO NANO SOMBREADO (sin globo blanco)
            L.polygon(closestWatermark.bounds, {
                color: "#2980b9", 
                weight: 3, 
                fillColor: "#2980b9",
                fillOpacity: 0.5,
                className: 'highlighted-polygon'
            }).addTo(selectionLayer);
            
            // Mostrar borde micro para referencia
            if (microWatermark) {
                L.polygon(microWatermark.bounds, {
                    color: "#3498db", 
                    weight: 2, 
                    fillColor: "transparent",
                    dashArray: "5, 5",
                    opacity: 0.4
                }).addTo(selectionLayer);
            }
        } else {
            // FALLBACK: Calcular manualmente si no se encuentra en cache
            const indices = calculateNanoIndicesFromPoint(e.latlng.lat, e.latlng.lng, hC[0].feature);
            microCode = getMicroCodeFromIndices(indices.microIx, indices.microIy);
            nanoCode = generateNanoCode(indices.nix, indices.niy, indices.microIx, indices.microIy);
            
            finalCode = `${macroID}-${microCode}-${nanoCode}`;
            
            const coords = hC[0].feature.geometry.coordinates[0];
            const nanoBounds = [
                getPointInGrid(coords, indices.microIx + indices.nix/NANO_RES, indices.microIy + indices.niy/NANO_RES, 24, 24),
                getPointInGrid(coords, indices.microIx + (indices.nix+1)/NANO_RES, indices.microIy + indices.niy/NANO_RES, 24, 24),
                getPointInGrid(coords, indices.microIx + (indices.nix+1)/NANO_RES, indices.microIy + (indices.niy+1)/NANO_RES, 24, 24),
                getPointInGrid(coords, indices.microIx + indices.nix/NANO_RES, indices.microIy + (indices.niy+1)/NANO_RES, 24, 24)
            ];
            
            L.polygon(nanoBounds, {
                color: "#2980b9", 
                weight: 3, 
                fillColor: "#2980b9",
                fillOpacity: 0.5,
                className: 'highlighted-polygon'
            }).addTo(selectionLayer);
        }

        console.log(`C√≥digo postal completo: ${finalCode}`);
        
        // OBTENER VM_LEVEL DEL POL√çGONO estafetas.geojson
        const vmLevel = obtenerVMLEVEL(e.latlng);
        
        // OBTENER √öLTIMOS 6 D√çGITOS DEL C√ìDIGO POSTAL
        const ultimos6Digitos = obtenerUltimos6Digitos(finalCode);
        
        // CREAR C√ìDIGO FINAL CON VM_LEVEL
        let codigoFinal = "";
        if (vmLevel) {
            codigoFinal = `${vmLevel}-${ultimos6Digitos}`;
        } else {
            codigoFinal = `SINVM-${ultimos6Digitos}`; // Si no hay VM_LEVEL
        }
        
        // Crear popup con evento para limpiar al cerrar
        const popupOffset = [0, -60];
        const popupLatLng = L.latLng(e.latlng.lat + 0.0004, e.latlng.lng);
        
        const popup = L.popup({offset: popupOffset, className: 'nano-popup'})
            .setLatLng(popupLatLng)
            .setContent(`
                <div style="text-align:center; padding: 15px; max-width: 350px;">
                    <div style="font-size: 16px; color: #1976d2; margin-bottom: 10px; font-weight: bold;">
                        üìç C√ìDIGO POSTAL
                    </div>
                    
                    <div class="codigo-completo">
                        <strong>PanamaCode:</strong> ${finalCode}
                    </div>
                    
                    <div class="codigo-final">
                        ${codigoFinal}
                    </div>
                    
                    <div style="font-size: 12px; color: #495057; margin: 10px 0; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                        GPS: ${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}
                    </div>
                    
                    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;">
                        <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${e.latlng.lat},${e.latlng.lng}')">üìç MAPS</button>
                        <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(`üìç PanamaCode: ${finalCode}\nC√≥digo Postal: ${codigoFinal}\nGPS: ${e.latlng.lat.toFixed(6)},${e.latlng.lng.toFixed(6)}`)}')">üí¨ WS</button>
                    </div>
                </div>
            `)
            .openOn(mymap);
        
        // Evento para limpiar selecci√≥n cuando se cierra el popup
        popup.on('remove', function() {
            selectionLayer.clearLayers();
            restoreHiddenLabels();
        });
    }
});

// FUNCI√ìN PARA MOSTRAR POPUP DE ZONA (REFERENCIA SOLO)
function mostrarPopupZona(latlng, zona) {
    const p = zona.properties || {};
    const nivelVM = p.VM_LEVEL || "N/A";
    const nombre = p.nombre || p.name || `Zona ${nivelVM}`;
    const fid = p.fid !== undefined ? p.fid : "N/A";
    
    const popupOffset = [0, -60];
    const popupLatLng = L.latLng(latlng.lat + 0.0004, latlng.lng);
    
    const popup = L.popup({offset: popupOffset, className: 'zona-popup'})
        .setLatLng(popupLatLng)
        .setContent(`
            <div style="text-align:center; padding: 10px; max-width: 280px;">
                <div style="font-size: 16px; color: #6c757d; margin-bottom: 8px; font-weight: bold;">
                    üó∫Ô∏è ${nombre}
                </div>
                <div style="font-size: 12px; color: #495057; margin-bottom: 12px; text-align: left; line-height: 1.4;">
                    <strong>Nivel VM:</strong> ${nivelVM}<br>
                    <strong>ID:</strong> ${fid}<br>
                    <strong>Tipo:</strong> Zona de Referencia<br>
                    <strong>Nota:</strong> Esta es solo una referencia visual
                </div>
                <div style="font-size: 11px; color: #868e96; margin-bottom: 12px; font-style: italic;">
                    Las zonas son solo para referencia. El c√≥digo postal viene de la cuadr√≠cula.
                </div>
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 10px;">
                    <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')">üìç MAPS</button>
                </div>
            </div>
        `)
        .openOn(mymap);
    
    // Resaltar la zona seleccionada
    selectionLayer.clearLayers();
    L.geoJSON(zona, {
        style: {
            color: "#6c757d", 
            weight: 4, 
            fillColor: "#6c757d",
            fillOpacity: 0.3,
            className: 'highlighted-polygon'
        }
    }).addTo(selectionLayer);
    
    popup.on('remove', function() {
        selectionLayer.clearLayers();
    });
}

// FUNCI√ìN PARA MOSTRAR POPUP DE ESTAFETA
function mostrarPopupEstafeta(latlng, estafeta) {
    const p = estafeta.properties || {};
    const nombre = p.ESTAF_NAME || p.nombre || p.name || "Estafeta Postal";
    const codigo = p.ESTAF_CODE || p.codigo || p.id || "N/A";
    const ruta = p.RUTA || "N/A";
    const nivel = p.VM_LEVEL || "N/A";
    const fid = p.fid !== undefined ? p.fid : "N/A";
    
    const popupOffset = [0, -60];
    const popupLatLng = L.latLng(latlng.lat + 0.0004, latlng.lng);
    
    const popup = L.popup({offset: popupOffset, className: 'estafeta-popup'})
        .setLatLng(popupLatLng)
        .setContent(`
            <div style="text-align:center; padding: 10px; max-width: 280px;">
                <div style="font-size: 16px; color: #28a745; margin-bottom: 8px; font-weight: bold;">
                    üìÆ ${nombre}
                </div>
                <div style="font-size: 12px; color: #155724; margin-bottom: 12px; text-align: left; line-height: 1.4;">
                    <strong>ID:</strong> ${fid}<br>
                    <strong>C√≥digo:</strong> ${codigo}<br>
                    <strong>Ruta:</strong> ${ruta}<br>
                    <strong>Nivel VM:</strong> ${nivel}
                </div>
                <div style="font-size: 11px; color: #0c5460; margin-bottom: 12px; font-style: italic;">
                    GPS: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}
                </div>
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 10px;">
                    <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')">üìç MAPS</button>
                    <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(`üìç Estafeta Postal: ${nombre}\nC√≥digo: ${codigo}\nRuta: ${ruta}\nGPS: ${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`)}')">üí¨ WS</button>
                </div>
            </div>
        `)
        .openOn(mymap);
    
    // Resaltar la estafeta seleccionada
    selectionLayer.clearLayers();
    L.circleMarker(latlng, {
        radius: 10,  // M√°s grande para mejor visibilidad
        color: "#28a745",
        fillColor: "#28a745",
        fillOpacity: 0.9,
        weight: 3
    }).addTo(selectionLayer);
    
    popup.on('remove', function() {
        selectionLayer.clearLayers();
    });
}

// FUNCI√ìN PARA MOSTRAR POPUP DE RUTA
function mostrarPopupRuta(latlng, ruta) {
    const p = ruta.properties || {};
    const rutaNombre = p.RUTA || p.nombre || p.name || "Ruta Postal";
    const tramo = p.tramo !== undefined ? p.tramo : "N/A";
    const distancia = p.distancia !== undefined ? `${parseFloat(p.distancia).toFixed(2)} m` : "N/A";
    const fid = p.fid !== undefined ? p.fid : "N/A";
    
    const popupOffset = [0, -60];
    const popupLatLng = L.latLng(latlng.lat + 0.0004, latlng.lng);
    
    const popup = L.popup({offset: popupOffset, className: 'ruta-popup'})
        .setLatLng(popupLatLng)
        .setContent(`
            <div style="text-align:center; padding: 10px; max-width: 280px;">
                <div style="font-size: 16px; color: #dc3545; margin-bottom: 8px; font-weight: bold;">
                    üöö Ruta: ${rutaNombre}
                </div>
                <div style="font-size: 12px; color: #721c24; margin-bottom: 12px; text-align: left; line-height: 1.4;">
                    <strong>ID:</strong> ${fid}<br>
                    <strong>Tramo:</strong> ${tramo}<br>
                    <strong>Distancia:</strong> ${distancia}<br>
                    <strong>Coordenadas:</strong> ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}
                </div>
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 10px;">
                    <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')">üìç MAPS</button>
                    <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(`üìç Ruta Postal: ${rutaNombre}\nTramo: ${tramo}\nDistancia: ${distancia}\nGPS: ${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`)}')">üí¨ WS</button>
                </div>
            </div>
        `)
        .openOn(mymap);
    
    // Resaltar el punto de la ruta seleccionada
    selectionLayer.clearLayers();
    L.circleMarker(latlng, {
        radius: 6,
        color: "#dc3545",
        fillColor: "#dc3545",
        fillOpacity: 0.8,
        weight: 3
    }).addTo(selectionLayer);
    
    // Tambi√©n resaltar la l√≠nea de la ruta
    if (ruta.geometry && (ruta.geometry.type === 'LineString' || ruta.geometry.type === 'MultiLineString')) {
        let latlngs = [];
        if (ruta.geometry.type === 'LineString') {
            latlngs = ruta.geometry.coordinates.map(coord => [coord[1], coord[0]]);
        } else if (ruta.geometry.type === 'MultiLineString') {
            // Para MultiLineString, tomar la primera l√≠nea
            latlngs = ruta.geometry.coordinates[0].map(coord => [coord[1], coord[0]]);
        }
        
        L.polyline(latlngs, {
            color: "#dc3545",
            weight: 4,
            opacity: 0.8
        }).addTo(selectionLayer);
    }
    
    popup.on('remove', function() {
        selectionLayer.clearLayers();
    });
}

// FUNCI√ìN PARA MOSTRAR POPUP DE √ÅREA NO DEFINIDA
function mostrarPopupAreaNoDefinida(latlng) {
    const popupOffset = [0, -60];
    const popupLatLng = L.latLng(latlng.lat + 0.0004, latlng.lng);
    
    L.popup({offset: popupOffset, className: 'warning-popup'})
        .setLatLng(popupLatLng)
        .setContent(`
            <div style="text-align:center; padding: 10px;">
                <div style="font-size: 16px; color: #e74c3c; margin-bottom: 5px;">
                    ‚ö†Ô∏è √ÅREA NO DEFINIDA
                </div>
                <div style="font-size: 12px; color: #7f8c8d; margin-bottom: 15px;">
                    Esta ubicaci√≥n se encuentra fuera de las zonas postales definidas
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')">üìç MAPS</button>
                    <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(`üìç Ubicaci√≥n fuera del sistema postal\nGPS: ${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`)}')">üí¨ WS</button>
                </div>
            </div>
        `)
        .openOn(mymap);
}

// BUSCADOR
document.getElementById('search-btn').addEventListener('click', () => {
    const input = document.getElementById('search-input').value.trim().toUpperCase();
    if (!input || !rawCuadricula) return;
    
    console.log(`Buscando: "${input}"`);
    
    // FORMATO 1: C√≥digo postal final (A7399-3M1J54)
    if (input.includes('-') && input.split('-').length === 2) {
        const [vmLevel, ultimos6] = input.split('-');
        
        // Buscar en TODOS los cuadros macro
        let encontrado = false;
        
        rawCuadricula.features.forEach((feat, featIndex) => {
            const codigoMacro = generarCodigoMacro(feat);
            
            // Simular clic en cada celda nano para generar c√≥digos
            for (let i = 0; i < 24 && !encontrado; i++) {
                for (let j = 0; j < 24 && !encontrado; j++) {
                    for (let ni = 0; ni < NANO_RES && !encontrado; ni++) {
                        for (let nj = 0; nj < NANO_RES && !encontrado; nj++) {
                            const microCode = getMicroCodeFromIndices(i, j);
                            const nanoCode = generateNanoCode(ni, nj, i, j);
                            const panamaCode = `${codigoMacro}-${microCode}-${nanoCode}`;
                            const ultimos6Panama = obtenerUltimos6Digitos(panamaCode);
                            
                            if (ultimos6Panama === ultimos6) {
                                console.log(`Encontrado: ${panamaCode}`);
                                
                                // Calcular coordenadas del centro de la celda nano
                                const coords = feat.geometry.coordinates[0];
                                const center = getPointInGrid(coords, 
                                    i + (ni + 0.5)/NANO_RES, 
                                    j + (nj + 0.5)/NANO_RES, 
                                    24, 24);
                                
                                mymap.setView(center, 18);
                                selectionLayer.clearLayers();
                                restoreHiddenLabels();
                                
                                // Mostrar celda nano
                                const nanoBounds = [
                                    getPointInGrid(coords, i + ni/NANO_RES, j + nj/NANO_RES, 24, 24),
                                    getPointInGrid(coords, i + (ni+1)/NANO_RES, j + nj/NANO_RES, 24, 24),
                                    getPointInGrid(coords, i + (ni+1)/NANO_RES, j + (nj+1)/NANO_RES, 24, 24),
                                    getPointInGrid(coords, i + ni/NANO_RES, j + (nj+1)/NANO_RES, 24, 24)
                                ];
                                
                                L.polygon(nanoBounds, {
                                    color: "#2980b9", 
                                    weight: 3, 
                                    fillColor: "#2980b9",
                                    fillOpacity: 0.5,
                                    className: 'highlighted-polygon'
                                }).addTo(selectionLayer);
                                
                                // Mostrar popup autom√°tico
                                setTimeout(() => {
                                    const popupLatLng = L.latLng(center[0] + 0.0004, center[1]);
                                    const codigoFinal = `${vmLevel}-${ultimos6}`;
                                    
                                    L.popup({offset: [0, -60], className: 'nano-popup'})
                                        .setLatLng(popupLatLng)
                                        .setContent(`
                                            <div style="text-align:center; padding: 15px; max-width: 350px;">
                                                <div style="font-size: 16px; color: #1976d2; margin-bottom: 10px; font-weight: bold;">
                                                    üìç RESULTADO DE B√öSQUEDA
                                                </div>
                                                <div class="codigo-completo">
                                                    <strong>PanamaCode:</strong> ${panamaCode}
                                                </div>
                                                <div class="codigo-final">
                                                    ${codigoFinal}
                                                </div>
                                                <div style="font-size: 12px; color: #495057; margin: 10px 0; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                                                    GPS: ${center[0].toFixed(6)}, ${center[1].toFixed(6)}
                                                </div>
                                            </div>
                                        `)
                                        .openOn(mymap);
                                }, 500);
                                
                                encontrado = true;
                                return;
                            }
                        }
                    }
                }
            }
        });
        
        if (!encontrado) {
            alert(`No se encontr√≥ el c√≥digo postal: ${input}`);
        }
        return;
    }
    
    // FORMATO 2: PanamaCode completo (AA4-P3M1-J54) o parcial
    const parts = input.split('-');
    const macroPart = parts[0];
    
    // Buscar c√≥digo macro
    let f = rawCuadricula.features.find(feat => {
        const codigoMacro = generarCodigoMacro(feat);
        return codigoMacro === macroPart;
    });
    
    if (f) {
        // Si solo es el macro (AA4)
        if (parts.length === 1) {
            mymap.fitBounds(L.geoJSON(f).getBounds(), {padding: [50, 50]});
            return;
        }
        
        // Si es macro-micro (AA4-P3M1)
        if (parts.length === 2) {
            const microPart = parts[1];
            if (microPart && microPart.length >= 2) {
                // Intentar extraer letras para √≠ndices
                const letras = microPart.match(/[A-Z]/g);
                if (letras && letras.length >= 2) {
                    const ix = ALFABETO.indexOf(letras[0]);
                    const iy = ALFABETO.indexOf(letras[1]);
                    
                    if (ix !== -1 && iy !== -1) {
                        const coords = f.geometry.coordinates[0];
                        const center = getPointInGrid(coords, ix + 0.5, iy + 0.5, 24, 24);
                        
                        mymap.setView(center, 16);
                        selectionLayer.clearLayers();
                        restoreHiddenLabels();
                        
                        const mRect = [
                            getPointInGrid(coords, ix, iy, 24, 24),
                            getPointInGrid(coords, ix+1, iy, 24, 24),
                            getPointInGrid(coords, ix+1, iy+1, 24, 24),
                            getPointInGrid(coords, ix, iy+1, 24, 24)
                        ];
                        
                        L.polygon(mRect, {
                            color: "#3498db", 
                            weight: 3, 
                            fillColor: "#3498db",
                            fillOpacity: 0.5,
                            className: 'highlighted-polygon'
                        }).addTo(selectionLayer);
                        
                        return;
                    }
                }
            }
        }
        
        // Si es completo macro-micro-nano (AA4-P3M1-J54)
        if (parts.length === 3) {
            const microPart = parts[1];
            const nanoPart = parts[2];
            
            if (microPart && microPart.length >= 2 && nanoPart && nanoPart.length >= 2) {
                const letrasMicro = microPart.match(/[A-Z]/g);
                const letraNano = nanoPart.charAt(0);
                const numerosNano = nanoPart.slice(1);
                
                if (letrasMicro && letrasMicro.length >= 2 && letraNano) {
                    const ix = ALFABETO.indexOf(letrasMicro[0]);
                    const iy = ALFABETO.indexOf(letrasMicro[1]);
                    const nanoLetraIndex = ALFABETO.indexOf(letraNano);
                    
                    if (ix !== -1 && iy !== -1 && nanoLetraIndex !== -1) {
                        // Buscar la celda nano espec√≠fica
                        const coords = f.geometry.coordinates[0];
                        
                        for (let ni = 0; ni < NANO_RES; ni++) {
                            for (let nj = 0; nj < NANO_RES; nj++) {
                                const nanoCodeGen = generateNanoCode(ni, nj, ix, iy);
                                if (nanoCodeGen === nanoPart) {
                                    const center = getPointInGrid(coords, 
                                        ix + (ni + 0.5)/NANO_RES, 
                                        iy + (nj + 0.5)/NANO_RES, 
                                        24, 24);
                                    
                                    mymap.setView(center, 18);
                                    selectionLayer.clearLayers();
                                    restoreHiddenLabels();
                                    
                                    const nanoBounds = [
                                        getPointInGrid(coords, ix + ni/NANO_RES, iy + nj/NANO_RES, 24, 24),
                                        getPointInGrid(coords, ix + (ni+1)/NANO_RES, iy + nj/NANO_RES, 24, 24),
                                        getPointInGrid(coords, ix + (ni+1)/NANO_RES, iy + (nj+1)/NANO_RES, 24, 24),
                                        getPointInGrid(coords, ix + ni/NANO_RES, iy + (nj+1)/NANO_RES, 24, 24)
                                    ];
                                    
                                    L.polygon(nanoBounds, {
                                        color: "#2980b9", 
                                        weight: 3, 
                                        fillColor: "#2980b9",
                                        fillOpacity: 0.5,
                                        className: 'highlighted-polygon'
                                    }).addTo(selectionLayer);
                                    
                                    return;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        mymap.fitBounds(L.geoJSON(f).getBounds(), {padding: [50, 50]});
    } 
    // FORMATO 3: Solo √∫ltimos 6 d√≠gitos (3M1J54)
    else if (input.length === 6 && !input.includes('-')) {
        // Buscar en todos los cuadros
        let encontrado = false;
        
        rawCuadricula.features.forEach((feat, featIndex) => {
            if (encontrado) return;
            
            const codigoMacro = generarCodigoMacro(feat);
            
            for (let i = 0; i < 24 && !encontrado; i++) {
                for (let j = 0; j < 24 && !encontrado; j++) {
                    for (let ni = 0; ni < NANO_RES && !encontrado; ni++) {
                        for (let nj = 0; nj < NANO_RES && !encontrado; nj++) {
                            const microCode = getMicroCodeFromIndices(i, j);
                            const nanoCode = generateNanoCode(ni, nj, i, j);
                            const panamaCode = `${codigoMacro}-${microCode}-${nanoCode}`;
                            const ultimos6 = obtenerUltimos6Digitos(panamaCode);
                            
                            if (ultimos6 === input) {
                                console.log(`Encontrado √∫ltimos 6 d√≠gitos: ${panamaCode}`);
                                
                                const coords = feat.geometry.coordinates[0];
                                const center = getPointInGrid(coords, 
                                    i + (ni + 0.5)/NANO_RES, 
                                    j + (nj + 0.5)/NANO_RES, 
                                    24, 24);
                                
                                mymap.setView(center, 18);
                                selectionLayer.clearLayers();
                                restoreHiddenLabels();
                                
                                const nanoBounds = [
                                    getPointInGrid(coords, i + ni/NANO_RES, j + nj/NANO_RES, 24, 24),
                                    getPointInGrid(coords, i + (ni+1)/NANO_RES, j + nj/NANO_RES, 24, 24),
                                    getPointInGrid(coords, i + (ni+1)/NANO_RES, j + (nj+1)/NANO_RES, 24, 24),
                                    getPointInGrid(coords, i + ni/NANO_RES, j + (nj+1)/NANO_RES, 24, 24)
                                ];
                                
                                L.polygon(nanoBounds, {
                                    color: "#2980b9", 
                                    weight: 3, 
                                    fillColor: "#2980b9",
                                    fillOpacity: 0.5,
                                    className: 'highlighted-polygon'
                                }).addTo(selectionLayer);
                                
                                encontrado = true;
                                
                                // Buscar VM_LEVEL para este punto
                                const vmLevel = obtenerVMLEVEL(L.latLng(center[0], center[1]));
                                const codigoFinal = vmLevel ? `${vmLevel}-${input}` : `SINVM-${input}`;
                                
                                setTimeout(() => {
                                    const popupLatLng = L.latLng(center[0] + 0.0004, center[1]);
                                    
                                    L.popup({offset: [0, -60], className: 'nano-popup'})
                                        .setLatLng(popupLatLng)
                                        .setContent(`
                                            <div style="text-align:center; padding: 15px; max-width: 350px;">
                                                <div style="font-size: 16px; color: #1976d2; margin-bottom: 10px; font-weight: bold;">
                                                    üìç B√öSQUEDA POR √öLTIMOS 6 D√çGITOS
                                                </div>
                                                <div class="codigo-completo">
                                                    <strong>PanamaCode:</strong> ${panamaCode}
                                                </div>
                                                <div class="codigo-final">
                                                    ${codigoFinal}
                                                </div>
                                                <div style="font-size: 12px; color: #495057; margin: 10px 0; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                                                    GPS: ${center[0].toFixed(6)}, ${center[1].toFixed(6)}
                                                </div>
                                            </div>
                                        `)
                                        .openOn(mymap);
                                }, 500);
                                
                                return;
                            }
                        }
                    }
                }
            }
        });
        
        if (!encontrado) {
            alert(`No se encontraron coincidencias para: ${input}`);
        }
    }
    else {
        alert("Formato no reconocido. Use:\n‚Ä¢ C√≥digo macro: AA4\n‚Ä¢ PanamaCode: AA4-P3M1-J54\n‚Ä¢ C√≥digo postal: A7399-3M1J54\n‚Ä¢ √öltimos 6 d√≠gitos: 3M1J54");
    }
});

// GPS
const LocateControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function() {
        const c = L.DomUtil.create('div', 'leaflet-bar');
        const b = L.DomUtil.create('a', 'locate-button', c);
        b.innerHTML = 'üéØ';
        b.title = "Ubicar mi posici√≥n";
        L.DomEvent.on(b, 'click', e => { 
            L.DomEvent.stopPropagation(e); 
            mymap.locate({setView:true, maxZoom:18}); 
        });
        return c;
    }
});
mymap.addControl(new LocateControl());

// CONTROL DE CAPAS
L.control.layers(null, {
    "Zonas (Referencia)": zonasGeoLayer,
    "Cuadr√≠cula": cuadriculaFisicaLayer,
    "Rutas": rutasLayer,
    "Estafetas": estafetasPointsLayer,
    "C√≥digo postal": gridLayer,
    "Selecci√≥n": selectionLayer,
    "Mi ubicaci√≥n": userLocationLayer
}, {collapsed: false}).addTo(mymap);

$('#toggle-wm').click(function() {
    labelsEnabled = !labelsEnabled;
    $(this).text(labelsEnabled ? "TEXTO: ON" : "TEXTO: OFF");
    updateGridAndLabels();
});

mymap.on('moveend zoomend', updateGridAndLabels);

mymap.on('locationfound', function(e) {
    userLocationLayer.clearLayers();
    
    L.marker(e.latlng, {
        icon: L.divIcon({
            className: 'user-location-icon',
            html: 'üìç',
            iconSize: [30, 30]
        }),
        zIndexOffset: 1000
    }).addTo(userLocationLayer);
    
    L.circle(e.latlng, {
        radius: e.accuracy / 2,
        color: '#3498db',
        fillColor: '#3498db',
        fillOpacity: 0.1,
        weight: 1
    }).addTo(userLocationLayer);
});

mymap.on('locationerror', function(e) {
    console.error("Error de ubicaci√≥n:", e.message);
});

// Tambi√©n limpiar selecci√≥n al hacer zoom o mover el mapa
mymap.on('zoomstart movestart', function() {
    selectionLayer.clearLayers();
    restoreHiddenLabels();
});

// Inicializar
updateGridAndLabels();
</script>
</body>
</html>




